import numpy as np
import torch
from torch.utils.data import Dataset

from colour_bomb import ColourBombGridworldV1Env, CBConfig


class CBSequenceDataset(Dataset):
    """
    Sequence dataset for Colour Bomb Gridworld v1.

    Each episode is generated by taking random actions in the gridworld.
    For each timestep t we store a 4-dimensional "transition token":
        [state_t, action_t, 0, 0]
    so that:
        observation_dim = 1
        action_dim      = 1
        joined_dim      = 4

    These flattened transitions are sliced into fixed-length sequences:
        x: seq_len tokens
        y: next-token targets
        mask: 1 for all positions (no padding here).
    """

    def __init__(
        self, num_episodes=1000, max_steps=200, sequence_length=200,
        discount=0.99, stochastic=False, seed=0
    ):
        self.sequence_length = sequence_length
        self.discount = discount

        cfg = CBConfig(max_steps=max_steps, stochastic=stochastic)
        self.env = ColourBombGridworldV1Env(cfg)

        rng = np.random.RandomState(seed)

        episodes_tokens = []

        for _ in range(num_episodes):
            s, _ = self.env.reset()
            states = []
            actions = []
            rewards = []
            
            for t in range(max_steps):
                a = rng.randint(self.env.action_space.n)
                ns, r, done, _ = self.env.step(a)
                states.append(s)
                actions.append(a)
                rewards.append(r)
                s = ns
                if done:
                    break

            T = len(states)
            if T == 0:
                continue

            values = np.zeros(T, dtype=np.float32)
            g = 0.0
            for t in reversed(range(T)):
                g = rewards[t] + discount * g
                values[t] = g

            tokens = np.zeros((T, 4), dtype=np.int64)
            for t in range(T):
                tokens[t, 0] = int(states[t])
                tokens[t, 1] = int(actions[t])
                tokens[t, 2] = 0
                tokens[t, 3] = 0

            # append an end/stop transition so DFAs can observe episode termination
            max_bin = max(self.env.observation_space.n, self.env.action_space.n, 1)
            end_token = max_bin  # aligns with adapter.num_token_ids - 1
            end_row = np.array([end_token] * 4, dtype=np.int64)
            tokens = np.vstack([tokens, end_row])

            episodes_tokens.append(tokens)

        indices = []
        self.rows_per_seg = max(1, sequence_length // 4)
        for ep_idx, rows in enumerate(episodes_tokens):
            R = rows.shape[0]
            if R < self.rows_per_seg + 1:
                continue
            starts = list(range(0, max(1, R - (self.rows_per_seg + 1)), self.rows_per_seg))
            tail = R - (self.rows_per_seg + 1)
            if tail not in starts:
                starts.append(tail)
            for start_row in starts:
                indices.append((ep_idx, start_row))

        self.episodes_tokens = episodes_tokens
        self.indices = indices

        self.observation_dim = 1
        self.action_dim = 1
        self.joined_dim = 4

    def __len__(self):
        return len(self.indices)

    def __getitem__(self, idx):
        ep_idx, start_row = self.indices[idx]
        rows = self.episodes_tokens[ep_idx]
        seg_rows = rows[start_row:start_row + self.rows_per_seg + 1]
        flat = seg_rows.reshape(-1)
        x = torch.from_numpy(flat[:-4].astype(np.int64))
        y = torch.from_numpy(flat[4:].astype(np.int64))
        mask = torch.ones_like(x, dtype=torch.float32)
        return x, y, mask
